/* $Id: html_dir.c,v 1.13 2004/04/21 22:39:23 te Exp $ */ 

/*
 * Copyright (c) 1999, 2002-2004 Tamer Embaby <tsemba@menanet.net>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * 21 Sep 1999  Tamer Embaby <tsemba@menanet.net>
 */

#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <string.h>
#include <errno.h>
#include <err.h>
#include <limits.h>
#include <sys/stat.h>
#include <unistd.h>
#include <time.h>
#include <fcntl.h>
#include <sys/types.h>
#if defined (__OpenBSD__)
# include <paths.h>
# include <util.h>
# include <sys/queue.h>
#elif defined (sun)
# include <bsd_list.h>
# include <fparseln.h>
#endif

#include <strlib.h>
#include <wsync.h>

static int depth, nelms, preserve;
static const char filename[15] = "index.html";
static const char *ldpre = "<!-- (@) fixed-code-begin -->";
static const char *ldpost = "<!-- (@) fixed-code-end -->";
static char preservefile[PATH_MAX];
static char *time_str;

static struct dir_names {
	struct	dir_names *d_next;
	char	d_name[PATH_MAX];
} *head;

struct entry_name {
	TAILQ_ENTRY(entry_name)
		e_link;
	struct	entry_name *e_next;	/* Entry name */
	char	e_name[PATH_MAX];
	char	e_dname[PATH_MAX];	/* Full path to entry name */
	int	e_depth;
	off_t	e_size;
};
TAILQ_HEAD(entry_head_t, entry_name);
struct entry_head_t ehead = TAILQ_HEAD_INITIALIZER(ehead);

static	void html_header(FILE *);
static	void html_tail(FILE *);
static	int do_list_dirs(char *,const char *,FILE *);
static	int fpath(char *,int);
static	int output(FILE *);
static	void checkpreserve(void);
static	void writepreserve(FILE *);
void	entry_insert_sorted(struct entry_name *);

char	*prsize(off_t);

static void
html_header(FILE *f)
{
	time_t t;
	char *p;
	char cwd[PATH_MAX];

	t = time(NULL);
	time_str = ctime(&t);
	getcwd(cwd, sizeof(cwd));
	if ((p = rindex(cwd, '/')) == NULL)
		p = cwd;
	else
		++p;

	time_str[strlen(time_str) - 1] = '\0';
	fprintf(f, 
	    "<!-- $Id: html_dir.c,v 1.13 2004/04/21 22:39:23 te Exp $ -->\n\n");
	fprintf(f, "<html>\n");
	fprintf(f, "<head>\n");
	fprintf(f, "<title>%s: table of contents</title>\n", p);
	fprintf(f, 
	    "<meta name=\"Generator\" content=\"wsync v%s\">\n", VERSION);
	fprintf(f, "\n<!-- %s -->\n\n", time_str);
	fprintf(f, "</head>\n");
	fprintf(f, "<body>\n\n");
	fprintf(f, "<h1><i>%s</i> table of contents</h1><br>\n\n", p);
	fprintf(f, "%s\n", ldpre);
	if (preserve != 0)
		writepreserve(f);
	fprintf(f, "%s\n\n", ldpost);
	return;
}

static void
html_tail(FILE *f)
{
	
	fprintf(f, "<hr noshade=\"noshade\">\n<i><small>");
	fprintf(f, "Generated by <b>wsync</b> v%s, ", VERSION);
	fprintf(f, "$Id: html_dir.c,v 1.13 2004/04/21 22:39:23 te Exp $\n");
	fprintf(f, "<br>%s</small></i>\n", time_str);
	fprintf(f, "</body>\n");
	fprintf(f, "</html>\n");
	return;
}

static int 
do_list_dirs(char *dir, const char *cdir, FILE *file)
{
	DIR *d;
	struct dirent *de;
	struct stat statbuf;
	struct dir_names *p, **pp;
	struct entry_name *e;

	if (head == NULL) {
		head = xmalloc(sizeof(struct dir_names));
		head->d_next = NULL;
		strlcpy(head->d_name, dir, sizeof(head->d_name));
		p = head;
	} else {
		for (pp = &head; p = *pp, p->d_next; pp = &p->d_next) 
			;
		p = *pp;
		p->d_next = xmalloc(sizeof(struct dir_names));
		p->d_next->d_next = NULL;
		strlcpy(p->d_next->d_name, dir, sizeof(p->d_next->d_name));
	}
	depth++;

	if ((d = opendir(dir)) == NULL) {
		warn("opedir(%s)", dir);
		return (-1);
	}

	if (cdir != NULL && chdir(cdir) < 0) {
		perror(cdir);
		return (-1);
	}
	
	while ((de = readdir(d)) != NULL) {
		if (strcmp(de->d_name, ".") == 0)
			continue;
		if (strcmp(de->d_name, "..") == 0)
			continue;
		if (strcmp(de->d_name, WSYNC_CONF) == 0)
			continue;
		if (strcmp(de->d_name, filename) == 0)
			continue;

		if (stat(de->d_name, &statbuf) < 0) {
			perror(de->d_name);
			return (-1);
		}

		if (S_ISDIR(statbuf.st_mode) != 0) {
			do_list_dirs(de->d_name, de->d_name, file);
		} else {
			e = xmalloc(sizeof(struct entry_name));
			strlcpy(e->e_name, de->d_name, sizeof(e->e_name));
			fpath(e->e_dname, sizeof(e->e_dname));
			e->e_depth = depth;
			e->e_next = NULL;
			e->e_size = statbuf.st_size;
			entry_insert_sorted(e);
			++nelms;
		}
	}

	if (cdir && (chdir("..") == -1) ) {
		perror(cdir);
		return (-1);
	}

	if (head == NULL)
		return (0);
	for (pp = &head; p = *pp, p->d_next; pp = &p->d_next)
		;
	free(p);
	*pp = NULL;
	depth--;
	return (0);
}

void
entry_insert_sorted(ep)
	struct	entry_name *ep;
{
	register struct entry_name *e;

	if (TAILQ_FIRST(&ehead) == NULL) {
		TAILQ_INSERT_HEAD(&ehead, ep, e_link);
		return;
	}
	TAILQ_FOREACH(e, &ehead, e_link) {
		if (e->e_depth > ep->e_depth)
			break;
#define STRGR(s1,s2)	(strcmp(s1, s2) > 0)
#define STRLT(s1,s2)	(strcmp(s1, s2) < 0)
#define STREQ(s1,s2)	(strcmp(s1, s2) == 0)
		if (e->e_depth == ep->e_depth)
			if (STRLT(ep->e_name, e->e_name))
				break;
	}
	if (e == NULL) {
		TAILQ_INSERT_TAIL(&ehead, ep, e_link);
		return;
	}
	TAILQ_INSERT_BEFORE(e, ep, e_link);
	return;
}

static int
fpath(buf, buflen)
	char	*buf;
	int	buflen;
{
	struct dir_names *it;
	
	buf[0] = 0;
	for (it = head; it != NULL; it = it->d_next) {
		if (strcmp(it->d_name, ".") == 0)
			continue;
		strlcat(buf, it->d_name, buflen);
		if (it->d_next != NULL)
			strlcat(buf, "/", buflen);
	}
	return (0);
}

static int
output(f)
	FILE *f;
{
	int c;
	char *color;
	struct entry_name *e;

	fprintf(f, "<table cellpadding=\"0\" cellspacing=\"0\" "
	    "border=\"0\" width=\"100%%\">\n\n");
	c = 0;
	color = "bgcolor=\"#c0c0c0\"";

	TAILQ_FOREACH(e, &ehead, e_link) {
		fprintf(f, "<tr>\n<td width=\"70%%\"");
		if ((++c & 1) == 1) {
			fprintf(f, " %s", color);
		}
		fprintf(f, ">\n<a href=");
		fprintf(f, "\"%s%s%s\"", e->e_dname,
		    e->e_dname[0] == '\0' ? "" : "/", e->e_name);
		fprintf(f, ">\n\t%s%s%s\n</a><br>\n", e->e_dname, 
		    e->e_dname[0] == '\0' ? "" : "/", e->e_name);
		fprintf(f, "</td>\n");
		fprintf(f, "<td width=\"30%%\"");
		if ((c & 1) == 1) {
			fprintf(f, " %s", color);
		}
		fprintf(f, ">%s</td>\n<tr>\n\n", prsize(e->e_size));
	}

	fprintf(f, "</table>\n");
	return (0);
}

char *
prsize(siz)
	off_t	siz;
{
	static char *units[] = { "B", "KB", "MB", "GB" };
	static char answer[128];
	char *p;
	float s;

	if (siz < 1024) {
		s = siz;
		p = units[0];
	} else if (siz < 1048576) {
		s = (float)siz / 1024;
		p = units[1];
	} else if (siz < 1073741824) {
		s = (float)siz / 1048576;
		p = units[2];
	} else {
		s = (float)siz / 1073741824;
		p = units[3];
	}
	snprintf(answer, sizeof(answer), "%.2f %s", s, p);
	return (answer);
}

static void
checkpreserve()
{
	int mark, fd;
	char *l;
	FILE *f;
	char buf[1024];

	if ((f = fopen(filename, "r")) == NULL)
		return;
	mark = 0;
	if ((fd = mkstemp(preservefile)) < 0) {
		return;
	}
	if (fcntl(fd, F_SETFD, 1) < 0) {
		return;
	}
	while ((l = fparseln(f, NULL, NULL, NULL, 0)) != NULL) {
		if (mark == 0 && strcmp(l, ldpre) == 0) {
			++mark;
			goto free_and_continue;
		}
		if (strcmp(l, ldpost) == 0 && mark != 0) {
			free(l);
			break;
		}
		if (mark != 0) {
			++preserve;
			snprintf(buf, sizeof(buf), "%s\n", l);
			if (write(fd, buf, strlen(buf)) < 0) {
				warn("write(%s)", preservefile);
				preserve = 0;
				free(l);
				break;
			}
		}
free_and_continue:
		free(l);
	}
	close(fd);
	fclose(f);
	if (preserve == 0)
		unlink(preservefile);
	return;
}

static void 
writepreserve(f)
	FILE	*f;
{
	char *l;
	FILE *f0;
	char buf[1024];

	if ((f0 = fopen(preservefile, "r")) == NULL)
		return;
	while ((l = fparseln(f0, NULL, NULL, NULL, 0)) != NULL) {
		snprintf(buf, sizeof(buf), "%s\n", l);
		if (fwrite(buf, strlen(buf), 1, f) != 1) {
			warn("fwrite(%s)", preservefile);
			free(l);
			break;
		}
		free(l);
	}
	fclose(f0);
	unlink(preservefile);
	return;
}

int 
htmldir(char *dir, const char *cdir)
{
	FILE *file;
	struct stat statbuf;

	nelms = depth = preserve = 0;
	if (stat(dir, &statbuf) < 0) {
		perror(dir);
		return (-1);
	}
	if (S_ISDIR(statbuf.st_mode) == 0)  
		return (-1);
	if (chdir(dir) < 0) {
		perror("chdir");
		return (-1);
	}
	snprintf(preservefile, sizeof(preservefile), 
	    "%s%s", _PATH_TMP, "wshd.XXXX");
	checkpreserve();
	if ((file = fopen(filename, "w")) == NULL) {
		warn("htmldir: fopen(%s)", filename);
		return (-1);
	}

	html_header(file);
	do_list_dirs(dir, cdir, file);
	output(file);
	html_tail(file);

	if (fclose(file) != 0) {
		perror(filename);
		return (-1);
	}
	return (0);
}
